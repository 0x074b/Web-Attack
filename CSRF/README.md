# CSRF
Cross-Site Request Forgery (CSRF) is a type of security vulnerability found in web applications. It enables attackers to perform actions on behalf of unsuspecting users by exploiting their authenticated sessions. The attack is executed when a user, who is logged into a victim's platform, visits a malicious site. This site then triggers requests to the victim's account through methods like executing JavaScript, submitting forms, or fetching images.

# Prerequisites
To exploit a CSRF vulnerability, several conditions must be met:

-Identify a Valuable Action: The attacker needs to find an action worth exploiting, such as changing the user's password, email, or elevating privileges.
-Session Management: The user's session should be managed solely through cookies or the HTTP Basic Authentication header, as other headers cannot be manipulated for this purpose.
-Absence of Unpredictable Parameters: The request should not contain unpredictable parameters, as they can prevent the attack.

# Defences Bypass

## From POST to GET
Maybe the form you want to abuse is prepared to send a **POST request with a CSRF token but**, you should check if a GET is also valid and if when you send a GET request the **CSRF token is still being validated.**

## Lack of token
Applications might implement a mechanism to **validate tokens** when they are present. However, a vulnerability arises if the validation is skipped altogether when the token is absent. Attackers can exploit this by **removing the parameter** that carries the token, not just its value. This allows them to circumvent the validation process and conduct a Cross-Site Request Forgery (CSRF) attack effectively.

## Token not tied to the user session
Applications not tying CSRF tokens to user sessions present a significant security risk. These systems verify tokens against a global pool rather than ensuring each token is bound to the initiating session.

- 1. **Authenticate** using their own account.
- 2. **Obtain a valid CSRF token** from the global pool.
- 3. **Use this token** in a CSRF attack against a victim.

This vulnerability allows attackers to make unauthorized requests on behalf of the victim, exploiting the application's **inadequate token validation mechanism.**

## Method bypass
If the request is using a "weird" method, check if the method override functionality is working. For example, if it's using a PUT method you can try to use a POST method and send: https://example.com/my/dear/api/val/num?_method=PUT

This could also works sending the _method parameter inside the a POST request or using the headers:

- X-HTTP-Method
- X-HTTP-Method-Override
- X-Method-Override

## Custom header token bypass
If the request is adding a custom header with a token to the request as CSRF protection method, then:

- Test the request without the **customized token and also header.**
- Test the request with exact **same length but different token.**

## CSRF token is verified by a cookie
Applications may implement CSRF protection by duplicating the token in both a cookie and a request parameter or by setting a CSRF cookie and verifying if the token sent in the backend corresponds to the cookie. The application validates requests by checking if the token in the request parameter aligns with the value in the cookie.

However, this method is vulnerable to CSRF attacks if the website has flaws allowing an attacker to set a CSRF cookie in the victim's browser, such as a CRLF vulnerability. The attacker can exploit this by loading a deceptive image that sets the cookie, followed by initiating the CSRF attack.

``` 
<html>
  <!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://example.com/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
  </body>
</html>
```
> [!NOTE]
> Note that if the **csrf token is related with the session cookie this attack won't work** because you will need to set the victim your session, and therefore you will be attacking yourself.

## Content-Type change
In order to avoid preflight requests using POST method these are the allowed Content-Type values:

- ```application/x-www-form-urlencoded```
- ```multipart/form-data```
- ```text/plain```

However, note that the severs logic may vary depending on the Content-Type used so you should try the values mentioned and others like ```application/json```, ```text/xml```, ```application/xml```

Example of sending JSON data as text/plain:
``` 
<html>
  <body>
    <form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
      <input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
    </form>
    <script>
        form.submit();
    </script>
  </body>
</html>
```
























